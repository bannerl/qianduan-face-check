
[参考链接](https://juejin.im/post/5afe6430518825428630bc4d)


>建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

### 观察者模式
定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。

### 发布订阅者模式

##### 观察者模式和发布订阅者模式的区别

在观察者模式中通知同一个特定的更新方法，而在发布订阅模式中则可以基于不同的主题去执行不同的自定义事件。相对而言，发布订阅模式比观察者模式要更加灵活多变。

从表面上看：

- 观察者模式里，只有两个角色 —— 观察者 + 被观察者
- 而发布订阅模式里，却不仅仅只有发布者和订阅者两个角色，还有一个经常被我们忽略的 —— 经纪人Broker

往更深层次讲：

- 观察者和被观察者，是松耦合的关系
- 发布者和订阅者，则完全不存在耦合

从使用层面上讲：
- 观察者模式，多用于单个应用内部
- 发布订阅模式，则更多的是一种跨应用的模式(crossapplication pattern)，比如我们常用的消息中间件

### 单例模式
单例模式的定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。实现的方法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。

适用场景：一个单一对象。比如：弹窗，无论点击多少次，弹窗只应该被创建一次。
vuex 和 redux中的store

### 迭代器模式
迭代器模式简单的说就是提供一种方法访问聚合对象中各个元素，而又不暴露该对象的内部行为。

优点：
 - 提供一致的遍历各种数据结构的方式，而不用了解数据的内部结构
- 提供遍历容器（集合）的能力而无需改变容器的接口

### 策略模式
策略模式的定义：定义一系列的算法，把他们一个个封装起来，并且使他们可以相互替换。
表单校验，根据场景进行不同方式的校验。

使用场景：购物车计算价格的时候可能对不同的优惠券和不同的活动有不同的算法，就可以通过策略模式设置不同的方法校验，减少了if的判断。

### 代理模式
代理模式的定义：为其他对象（被代理对象）提供一种代理以控制对原有对象的操作。实际的行为是由被代理对象完成的。
特点：
代理对象和本体对象具有一致的接口, 对使用者友好
代理种类：
代理模式的种类有很多, 在 JS 中最常用的为虚拟代理和缓存代理。

还有```addEventListener```就是代理，可以代理子元素。

### 装饰者模式
装饰者模式的定义：在不改变对象自身的基础上，在程序运行期间给对象动态地添加方法。

装饰者模式适用的场景：原有方法维持不变，在原有方法上再挂载其他方法来满足现有需求；函数的解耦，将函数拆分成多个可复用的函数，再将拆分出来的函数挂载到某个函数上，实现相同的效果但增强了复用性。

### 职责链模式
定义：类似多米诺骨牌, 通过请求第一个条件, 会持续执行后续的条件, 直到返回结果为止。
就像我们不同情况请求不同的接口，就可以根据职责链的条件进行判断。总有几个接口会请求

### 状态模式
定义: 将事物内部的每个状态分别封装成类, 内部状态改变会产生不同行为。
优点: 用对象代替字符串记录当前状态, 状态易维护
缺点: 需编写大量状态类对象

### 适配者模式
定义: 主要用于解决两个接口之间不匹配的问题。

### 外观模式
定义：为子系统中的一组接口提供一个统一的高层接口，使子系统更容易使用。简而言之外观设计模式就是把多个子系统中复杂逻辑进行抽象，从而提供一个更统一、更简洁、更易用的API

示例：
JQuery就把复杂的原生DOM操作进行了抽象和封装，并消除了浏览器之间的兼容问题，从而提供了一个更高级更易用的版本

### 中介者模式
定义：在中介者模式中，中介者（Mediator）包装了一系列对象相互作用的方式，使得这些对象不必直接相互作用，而是由中介者协调它们之间的交互，从而使它们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用，保证这些作用可以彼此独立的变化。

示例：运营后台表格操作栏的功能按钮就可以交由一个方法根据传入类型执行不同方法，实现各个事件的解耦，交由中介者去维护。



